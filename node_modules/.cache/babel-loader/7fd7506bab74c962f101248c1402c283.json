{"ast":null,"code":"import BaseInput from \"./baseInput\";\nimport Util from \"./util\";\n\nconst BaseSelection = ($ => {\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n  const Default = {\n    label: {\n      required: false // Prioritized find order for resolving the label to be used as an bmd-label if not specified in the markup\n      //  - a function(thisComponent); or\n      //  - a string selector used like $bmdFormGroup.find(selector)\n      //\n      // Note this only runs if $bmdFormGroup.find(Selector.BMD_LABEL_WILDCARD) fails to find a label (as authored in the markup)\n      //\n      //selectors: [\n      //  `.form-control-label`, // in the case of horizontal or inline forms, this will be marked\n      //  `> label` // usual case for text inputs\n      //]\n\n    }\n  };\n  const Selector = {\n    LABEL: \"label\"\n  };\n  /**\n   * ------------------------------------------------------------------------\n   * Class Definition\n   * ------------------------------------------------------------------------\n   */\n\n  class BaseSelection extends BaseInput {\n    constructor($element, config, properties) {\n      // properties = {inputType: checkbox, outerClass: checkbox-inline}\n      // '.checkbox|switch|radio > label > input[type=checkbox|radio]'\n      // '.${this.outerClass} > label > input[type=${this.inputType}]'\n      super($element, $.extend(true, {}, Default, config), properties);\n      this.decorateMarkup();\n    } // ------------------------------------------------------------------------\n    // protected\n\n\n    decorateMarkup() {\n      const $decorator = $(this.config.template);\n      this.$element.after($decorator); // initialize ripples after decorator has been inserted into DOM\n\n      if (this.config.ripples !== false) {\n        $decorator.bmdRipples();\n      }\n    } // Demarcation element (e.g. first child of a form-group)\n\n\n    outerElement() {\n      // .checkbox|switch|radio > label > input[type=checkbox|radio]\n      // label.checkbox-inline > input[type=checkbox|radio]\n      // .${this.outerClass} > label > input[type=${this.inputType}]\n      return this.$element.parent().closest(`.${this.outerClass}`);\n    }\n\n    rejectWithoutRequiredStructure() {\n      // '.checkbox|switch|radio > label > input[type=checkbox|radio]'\n      // '.${this.outerClass} > label > input[type=${this.inputType}]'\n      Util.assert(this.$element, !this.$element.parent().prop(\"tagName\") === \"label\", `${this.constructor.name}'s ${Util.describe(this.$element)} parent element should be <label>.`);\n      Util.assert(this.$element, !this.outerElement().hasClass(this.outerClass), `${this.constructor.name}'s ${Util.describe(this.$element)} outer element should have class ${this.outerClass}.`);\n    }\n\n    addFocusListener() {\n      // checkboxes didn't appear to bubble to the document, so we'll bind these directly\n      this.$element.closest(Selector.LABEL).hover(() => {\n        this.addFormGroupFocus();\n      }, () => {\n        this.removeFormGroupFocus();\n      });\n    }\n\n    addChangeListener() {\n      this.$element.change(() => {\n        this.$element.blur();\n      });\n    } // ------------------------------------------------------------------------\n    // private\n\n\n  }\n\n  return BaseSelection;\n})(jQuery);\n\nexport default BaseSelection;","map":{"version":3,"sources":["/Users/aaron/Desktop/my-app/node_modules/bootstrap-material-design/js/baseSelection.js"],"names":["BaseInput","Util","BaseSelection","$","Default","label","required","Selector","LABEL","constructor","$element","config","properties","extend","decorateMarkup","$decorator","template","after","ripples","bmdRipples","outerElement","parent","closest","outerClass","rejectWithoutRequiredStructure","assert","prop","name","describe","hasClass","addFocusListener","hover","addFormGroupFocus","removeFormGroupFocus","addChangeListener","change","blur","jQuery"],"mappings":"AAAA,OAAOA,SAAP,MAAsB,aAAtB;AACA,OAAOC,IAAP,MAAiB,QAAjB;;AAEA,MAAMC,aAAa,GAAG,CAACC,CAAC,IAAI;AAC1B;;;;;AAKA,QAAMC,OAAO,GAAG;AACdC,IAAAA,KAAK,EAAE;AACLC,MAAAA,QAAQ,EAAE,KADL,CAGL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAZK;AADO,GAAhB;AAiBA,QAAMC,QAAQ,GAAG;AACfC,IAAAA,KAAK,EAAE;AADQ,GAAjB;AAIA;;;;;;AAKA,QAAMN,aAAN,SAA4BF,SAA5B,CAAsC;AACpCS,IAAAA,WAAW,CAACC,QAAD,EAAWC,MAAX,EAAmBC,UAAnB,EAA+B;AACxC;AACA;AACA;AAEA,YAAMF,QAAN,EAAgBP,CAAC,CAACU,MAAF,CAAS,IAAT,EAAe,EAAf,EAAmBT,OAAnB,EAA4BO,MAA5B,CAAhB,EAAqDC,UAArD;AACA,WAAKE,cAAL;AACD,KARmC,CAUpC;AACA;;;AAEAA,IAAAA,cAAc,GAAG;AACf,YAAMC,UAAU,GAAGZ,CAAC,CAAC,KAAKQ,MAAL,CAAYK,QAAb,CAApB;AACA,WAAKN,QAAL,CAAcO,KAAd,CAAoBF,UAApB,EAFe,CAIf;;AACA,UAAI,KAAKJ,MAAL,CAAYO,OAAZ,KAAwB,KAA5B,EAAmC;AACjCH,QAAAA,UAAU,CAACI,UAAX;AACD;AACF,KArBmC,CAuBpC;;;AACAC,IAAAA,YAAY,GAAG;AACb;AACA;AACA;AACA,aAAO,KAAKV,QAAL,CAAcW,MAAd,GAAuBC,OAAvB,CAAgC,IAAG,KAAKC,UAAW,EAAnD,CAAP;AACD;;AAEDC,IAAAA,8BAA8B,GAAG;AAC/B;AACA;AACAvB,MAAAA,IAAI,CAACwB,MAAL,CACE,KAAKf,QADP,EAEE,CAAC,KAAKA,QAAL,CAAcW,MAAd,GAAuBK,IAAvB,CAA4B,SAA5B,CAAD,KAA4C,OAF9C,EAGG,GAAE,KAAKjB,WAAL,CAAiBkB,IAAK,MAAK1B,IAAI,CAAC2B,QAAL,CAC5B,KAAKlB,QADuB,CAE5B,oCALJ;AAOAT,MAAAA,IAAI,CAACwB,MAAL,CACE,KAAKf,QADP,EAEE,CAAC,KAAKU,YAAL,GAAoBS,QAApB,CAA6B,KAAKN,UAAlC,CAFH,EAGG,GAAE,KAAKd,WAAL,CAAiBkB,IAAK,MAAK1B,IAAI,CAAC2B,QAAL,CAC5B,KAAKlB,QADuB,CAE5B,oCAAmC,KAAKa,UAAW,GALvD;AAOD;;AAEDO,IAAAA,gBAAgB,GAAG;AACjB;AACA,WAAKpB,QAAL,CAAcY,OAAd,CAAsBf,QAAQ,CAACC,KAA/B,EAAsCuB,KAAtC,CACE,MAAM;AACJ,aAAKC,iBAAL;AACD,OAHH,EAIE,MAAM;AACJ,aAAKC,oBAAL;AACD,OANH;AAQD;;AAEDC,IAAAA,iBAAiB,GAAG;AAClB,WAAKxB,QAAL,CAAcyB,MAAd,CAAqB,MAAM;AACzB,aAAKzB,QAAL,CAAc0B,IAAd;AACD,OAFD;AAGD,KAlEmC,CAoEpC;AACA;;;AArEoC;;AAwEtC,SAAOlC,aAAP;AACD,CAzGqB,EAyGnBmC,MAzGmB,CAAtB;;AA2GA,eAAenC,aAAf","sourcesContent":["import BaseInput from \"./baseInput\";\nimport Util from \"./util\";\n\nconst BaseSelection = ($ => {\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n  const Default = {\n    label: {\n      required: false\n\n      // Prioritized find order for resolving the label to be used as an bmd-label if not specified in the markup\n      //  - a function(thisComponent); or\n      //  - a string selector used like $bmdFormGroup.find(selector)\n      //\n      // Note this only runs if $bmdFormGroup.find(Selector.BMD_LABEL_WILDCARD) fails to find a label (as authored in the markup)\n      //\n      //selectors: [\n      //  `.form-control-label`, // in the case of horizontal or inline forms, this will be marked\n      //  `> label` // usual case for text inputs\n      //]\n    }\n  };\n\n  const Selector = {\n    LABEL: \"label\"\n  };\n\n  /**\n   * ------------------------------------------------------------------------\n   * Class Definition\n   * ------------------------------------------------------------------------\n   */\n  class BaseSelection extends BaseInput {\n    constructor($element, config, properties) {\n      // properties = {inputType: checkbox, outerClass: checkbox-inline}\n      // '.checkbox|switch|radio > label > input[type=checkbox|radio]'\n      // '.${this.outerClass} > label > input[type=${this.inputType}]'\n\n      super($element, $.extend(true, {}, Default, config), properties);\n      this.decorateMarkup();\n    }\n\n    // ------------------------------------------------------------------------\n    // protected\n\n    decorateMarkup() {\n      const $decorator = $(this.config.template);\n      this.$element.after($decorator);\n\n      // initialize ripples after decorator has been inserted into DOM\n      if (this.config.ripples !== false) {\n        $decorator.bmdRipples();\n      }\n    }\n\n    // Demarcation element (e.g. first child of a form-group)\n    outerElement() {\n      // .checkbox|switch|radio > label > input[type=checkbox|radio]\n      // label.checkbox-inline > input[type=checkbox|radio]\n      // .${this.outerClass} > label > input[type=${this.inputType}]\n      return this.$element.parent().closest(`.${this.outerClass}`);\n    }\n\n    rejectWithoutRequiredStructure() {\n      // '.checkbox|switch|radio > label > input[type=checkbox|radio]'\n      // '.${this.outerClass} > label > input[type=${this.inputType}]'\n      Util.assert(\n        this.$element,\n        !this.$element.parent().prop(\"tagName\") === \"label\",\n        `${this.constructor.name}'s ${Util.describe(\n          this.$element\n        )} parent element should be <label>.`\n      );\n      Util.assert(\n        this.$element,\n        !this.outerElement().hasClass(this.outerClass),\n        `${this.constructor.name}'s ${Util.describe(\n          this.$element\n        )} outer element should have class ${this.outerClass}.`\n      );\n    }\n\n    addFocusListener() {\n      // checkboxes didn't appear to bubble to the document, so we'll bind these directly\n      this.$element.closest(Selector.LABEL).hover(\n        () => {\n          this.addFormGroupFocus();\n        },\n        () => {\n          this.removeFormGroupFocus();\n        }\n      );\n    }\n\n    addChangeListener() {\n      this.$element.change(() => {\n        this.$element.blur();\n      });\n    }\n\n    // ------------------------------------------------------------------------\n    // private\n  }\n\n  return BaseSelection;\n})(jQuery);\n\nexport default BaseSelection;\n"]},"metadata":{},"sourceType":"module"}