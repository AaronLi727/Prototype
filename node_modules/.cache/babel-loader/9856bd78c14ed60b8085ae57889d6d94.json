{"ast":null,"code":"import Base from \"./base\";\nimport Util from \"./util\";\n\nconst BaseInput = ($ => {\n  const ClassName = {\n    FORM_GROUP: \"form-group\",\n    BMD_FORM_GROUP: \"bmd-form-group\",\n    BMD_LABEL: \"bmd-label\",\n    BMD_LABEL_STATIC: \"bmd-label-static\",\n    BMD_LABEL_PLACEHOLDER: \"bmd-label-placeholder\",\n    BMD_LABEL_FLOATING: \"bmd-label-floating\",\n    HAS_DANGER: \"has-danger\",\n    IS_FILLED: \"is-filled\",\n    IS_FOCUSED: \"is-focused\",\n    INPUT_GROUP: \"input-group\"\n  };\n  const Selector = {\n    FORM_GROUP: `.${ClassName.FORM_GROUP}`,\n    BMD_FORM_GROUP: `.${ClassName.BMD_FORM_GROUP}`,\n    BMD_LABEL_WILDCARD: `label[class^='${ClassName.BMD_LABEL}'], label[class*=' ${ClassName.BMD_LABEL}']` // match any label variant if specified\n\n  };\n  const Default = {\n    validate: false,\n    formGroup: {\n      required: false\n    },\n    bmdFormGroup: {\n      template: `<span class='${ClassName.BMD_FORM_GROUP}'></span>`,\n      create: true,\n      // create a wrapper if form-group not found\n      required: true // not recommended to turn this off, only used for inline components\n\n    },\n    label: {\n      required: false,\n      // Prioritized find order for resolving the label to be used as an bmd-label if not specified in the markup\n      //  - a function(thisComponent); or\n      //  - a string selector used like $bmdFormGroup.find(selector)\n      //\n      // Note this only runs if $bmdFormGroup.find(Selector.BMD_LABEL_WILDCARD) fails to find a label (as authored in the markup)\n      //\n      selectors: [`.form-control-label`, // in the case of horizontal or inline forms, this will be marked\n      `> label` // usual case for text inputs, first child.  Deeper would find toggle labels so don't do that.\n      ],\n      className: ClassName.BMD_LABEL_STATIC\n    },\n    requiredClasses: [],\n    invalidComponentMatches: [],\n    convertInputSizeVariations: true\n  };\n  const FormControlSizeMarkers = {\n    \"form-control-lg\": \"bmd-form-group-lg\",\n    \"form-control-sm\": \"bmd-form-group-sm\"\n  };\n  /**\n   * ------------------------------------------------------------------------\n   * Class Definition\n   * ------------------------------------------------------------------------\n   */\n\n  class BaseInput extends Base {\n    /**\n     *\n     * @param element\n     * @param config\n     * @param properties - anything that needs to be set as this[key] = value.  Works around the need to call `super` before using `this`\n     */\n    constructor($element, config, properties = {}) {\n      super($element, $.extend(true, {}, Default, config), properties); // Enforce no overlap between components to prevent side effects\n\n      this._rejectInvalidComponentMatches(); // Enforce expected structure (if any)\n\n\n      this.rejectWithoutRequiredStructure(); // Enforce required classes for a consistent rendering\n\n      this._rejectWithoutRequiredClasses(); // Resolve the form-group first, it will be used for bmd-form-group if possible\n      //   note: different components have different rules\n\n\n      this.$formGroup = this.findFormGroup(this.config.formGroup.required); // Will add bmd-form-group to form-group or create an bmd-form-group\n      //  Performance Note: for those forms that are really performance driven, create the markup with the .bmd-form-group to avoid\n      //    rendering changes once added.\n\n      this.$bmdFormGroup = this.resolveMdbFormGroup(); // Resolve and mark the bmdLabel if necessary as defined by the config\n\n      this.$bmdLabel = this.resolveMdbLabel(); // Signal to the bmd-form-group that a form-control-* variation is being used\n\n      this.resolveMdbFormGroupSizing();\n      this.addFocusListener();\n      this.addChangeListener();\n\n      if (this.$element.val() != \"\") {\n        this.addIsFilled();\n      }\n    }\n\n    dispose(dataKey) {\n      super.dispose(dataKey);\n      this.$bmdFormGroup = null;\n      this.$formGroup = null;\n    } // ------------------------------------------------------------------------\n    // protected\n\n\n    rejectWithoutRequiredStructure() {// implement\n    }\n\n    addFocusListener() {\n      this.$element.on(\"focus\", () => {\n        this.addFormGroupFocus();\n      }).on(\"blur\", () => {\n        this.removeFormGroupFocus();\n      });\n    }\n\n    addChangeListener() {\n      this.$element.on(\"keydown paste\", event => {\n        if (Util.isChar(event)) {\n          this.addIsFilled();\n        }\n      }).on(\"keyup change\", () => {\n        // make sure empty is added back when there is a programmatic value change.\n        //  NOTE: programmatic changing of value using $.val() must trigger the change event i.e. $.val('x').trigger('change')\n        if (this.isEmpty()) {\n          this.removeIsFilled();\n        } else {\n          this.addIsFilled();\n        }\n\n        if (this.config.validate) {\n          // Validation events do not bubble, so they must be attached directly to the text: http://jsfiddle.net/PEpRM/1/\n          //  Further, even the bind method is being caught, but since we are already calling #checkValidity here, just alter\n          //  the form-group on change.\n          //\n          // NOTE: I'm not sure we should be intervening regarding validation, this seems better as a README and snippet of code.\n          //        BUT, I've left it here for backwards compatibility.\n          let isValid = typeof this.$element[0].checkValidity === \"undefined\" || this.$element[0].checkValidity();\n\n          if (isValid) {\n            this.removeHasDanger();\n          } else {\n            this.addHasDanger();\n          }\n        }\n      });\n    }\n\n    addHasDanger() {\n      this.$bmdFormGroup.addClass(ClassName.HAS_DANGER);\n    }\n\n    removeHasDanger() {\n      this.$bmdFormGroup.removeClass(ClassName.HAS_DANGER);\n    }\n\n    isEmpty() {\n      return this.$element.val() === null || this.$element.val() === undefined || this.$element.val() === \"\";\n    } // Will add bmd-form-group to form-group or create a bmd-form-group if necessary\n\n\n    resolveMdbFormGroup() {\n      let mfg = this.findMdbFormGroup(false);\n\n      if (mfg === undefined || mfg.length === 0) {\n        if (this.config.bmdFormGroup.create && (this.$formGroup === undefined || this.$formGroup.length === 0)) {\n          // If a form-group doesn't exist (not recommended), take a guess and wrap the element (assuming no label).\n          //  note: it's possible to make this smarter, but I need to see valid cases before adding any complexity.\n          // this may be an input-group, wrap that instead\n          if (this.outerElement().parent().hasClass(ClassName.INPUT_GROUP)) {\n            this.outerElement().parent().wrap(this.config.bmdFormGroup.template);\n          } else {\n            this.outerElement().wrap(this.config.bmdFormGroup.template);\n          }\n        } else {\n          // a form-group does exist, add our marker class to it\n          this.$formGroup.addClass(ClassName.BMD_FORM_GROUP); // OLD: may want to implement this after all, see how the styling turns out, but using an existing form-group is less manipulation of the dom and therefore preferable\n          // A form-group does exist, so add an bmd-form-group wrapping it's internal contents\n          //fg.wrapInner(this.config.bmdFormGroup.template)\n        }\n\n        mfg = this.findMdbFormGroup(this.config.bmdFormGroup.required);\n      }\n\n      return mfg;\n    } // Demarcation element (e.g. first child of a form-group)\n    //  Subclasses such as file inputs may have different structures\n\n\n    outerElement() {\n      return this.$element;\n    } // Will add bmd-label to bmd-form-group if not already specified\n\n\n    resolveMdbLabel() {\n      let label = this.$bmdFormGroup.find(Selector.BMD_LABEL_WILDCARD);\n\n      if (label === undefined || label.length === 0) {\n        // we need to find it based on the configured selectors\n        label = this.findMdbLabel(this.config.label.required);\n\n        if (label === undefined || label.length === 0) {// no label found, and finder did not require one\n        } else {\n          // a candidate label was found, add the configured default class name\n          label.addClass(this.config.label.className);\n        }\n      }\n\n      return label;\n    } // Find bmd-label variant based on the config selectors\n\n\n    findMdbLabel(raiseError = true) {\n      let label = null; // use the specified selector order\n\n      for (let selector of this.config.label.selectors) {\n        if ($.isFunction(selector)) {\n          label = selector(this);\n        } else {\n          label = this.$bmdFormGroup.find(selector);\n        }\n\n        if (label !== undefined && label.length > 0) {\n          break;\n        }\n      }\n\n      if (label.length === 0 && raiseError) {\n        $.error(`Failed to find ${Selector.BMD_LABEL_WILDCARD} within form-group for ${Util.describe(this.$element)}`);\n      }\n\n      return label;\n    } // Find bmd-form-group\n\n\n    findFormGroup(raiseError = true) {\n      let fg = this.$element.closest(Selector.FORM_GROUP);\n\n      if (fg.length === 0 && raiseError) {\n        $.error(`Failed to find ${Selector.FORM_GROUP} for ${Util.describe(this.$element)}`);\n      }\n\n      return fg;\n    } // Due to the interconnected nature of labels/inputs/help-blocks, signal the bmd-form-group-* size variation based on\n    //  a found form-control-* size\n\n\n    resolveMdbFormGroupSizing() {\n      if (!this.config.convertInputSizeVariations) {\n        return;\n      } // Modification - Change text-sm/lg to form-group-sm/lg instead (preferred standard and simpler css/less variants)\n\n\n      for (let inputSize in FormControlSizeMarkers) {\n        if (this.$element.hasClass(inputSize)) {\n          //this.$element.removeClass(inputSize)\n          this.$bmdFormGroup.addClass(FormControlSizeMarkers[inputSize]);\n        }\n      }\n    } // ------------------------------------------------------------------------\n    // private\n\n\n    _rejectInvalidComponentMatches() {\n      for (let otherComponent of this.config.invalidComponentMatches) {\n        otherComponent.rejectMatch(this.constructor.name, this.$element);\n      }\n    }\n\n    _rejectWithoutRequiredClasses() {\n      for (let requiredClass of this.config.requiredClasses) {\n        let found = false; // allow one of several classes to be passed in x||y\n\n        if (requiredClass.indexOf(\"||\") !== -1) {\n          let oneOf = requiredClass.split(\"||\");\n\n          for (let requiredClass of oneOf) {\n            if (this.$element.hasClass(requiredClass)) {\n              found = true;\n              break;\n            }\n          }\n        } else if (this.$element.hasClass(requiredClass)) {\n          found = true;\n        }\n      }\n    } // ------------------------------------------------------------------------\n    // static\n\n\n  }\n\n  return BaseInput;\n})(jQuery);\n\nexport default BaseInput;","map":{"version":3,"sources":["/Users/aaron/Desktop/my-app/node_modules/bootstrap-material-design/js/baseInput.js"],"names":["Base","Util","BaseInput","$","ClassName","FORM_GROUP","BMD_FORM_GROUP","BMD_LABEL","BMD_LABEL_STATIC","BMD_LABEL_PLACEHOLDER","BMD_LABEL_FLOATING","HAS_DANGER","IS_FILLED","IS_FOCUSED","INPUT_GROUP","Selector","BMD_LABEL_WILDCARD","Default","validate","formGroup","required","bmdFormGroup","template","create","label","selectors","className","requiredClasses","invalidComponentMatches","convertInputSizeVariations","FormControlSizeMarkers","constructor","$element","config","properties","extend","_rejectInvalidComponentMatches","rejectWithoutRequiredStructure","_rejectWithoutRequiredClasses","$formGroup","findFormGroup","$bmdFormGroup","resolveMdbFormGroup","$bmdLabel","resolveMdbLabel","resolveMdbFormGroupSizing","addFocusListener","addChangeListener","val","addIsFilled","dispose","dataKey","on","addFormGroupFocus","removeFormGroupFocus","event","isChar","isEmpty","removeIsFilled","isValid","checkValidity","removeHasDanger","addHasDanger","addClass","removeClass","undefined","mfg","findMdbFormGroup","length","outerElement","parent","hasClass","wrap","find","findMdbLabel","raiseError","selector","isFunction","error","describe","fg","closest","inputSize","otherComponent","rejectMatch","name","requiredClass","found","indexOf","oneOf","split","jQuery"],"mappings":"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","sourcesContent":["import Base from \"./base\";\nimport Util from \"./util\";\n\nconst BaseInput = ($ => {\n  const ClassName = {\n    FORM_GROUP: \"form-group\",\n    BMD_FORM_GROUP: \"bmd-form-group\",\n    BMD_LABEL: \"bmd-label\",\n    BMD_LABEL_STATIC: \"bmd-label-static\",\n    BMD_LABEL_PLACEHOLDER: \"bmd-label-placeholder\",\n    BMD_LABEL_FLOATING: \"bmd-label-floating\",\n    HAS_DANGER: \"has-danger\",\n    IS_FILLED: \"is-filled\",\n    IS_FOCUSED: \"is-focused\",\n    INPUT_GROUP: \"input-group\"\n  };\n\n  const Selector = {\n    FORM_GROUP: `.${ClassName.FORM_GROUP}`,\n    BMD_FORM_GROUP: `.${ClassName.BMD_FORM_GROUP}`,\n    BMD_LABEL_WILDCARD: `label[class^='${ClassName.BMD_LABEL}'], label[class*=' ${ClassName.BMD_LABEL}']` // match any label variant if specified\n  };\n\n  const Default = {\n    validate: false,\n    formGroup: {\n      required: false\n    },\n    bmdFormGroup: {\n      template: `<span class='${ClassName.BMD_FORM_GROUP}'></span>`,\n      create: true, // create a wrapper if form-group not found\n      required: true // not recommended to turn this off, only used for inline components\n    },\n    label: {\n      required: false,\n\n      // Prioritized find order for resolving the label to be used as an bmd-label if not specified in the markup\n      //  - a function(thisComponent); or\n      //  - a string selector used like $bmdFormGroup.find(selector)\n      //\n      // Note this only runs if $bmdFormGroup.find(Selector.BMD_LABEL_WILDCARD) fails to find a label (as authored in the markup)\n      //\n      selectors: [\n        `.form-control-label`, // in the case of horizontal or inline forms, this will be marked\n        `> label` // usual case for text inputs, first child.  Deeper would find toggle labels so don't do that.\n      ],\n      className: ClassName.BMD_LABEL_STATIC\n    },\n    requiredClasses: [],\n    invalidComponentMatches: [],\n    convertInputSizeVariations: true\n  };\n\n  const FormControlSizeMarkers = {\n    \"form-control-lg\": \"bmd-form-group-lg\",\n    \"form-control-sm\": \"bmd-form-group-sm\"\n  };\n\n  /**\n   * ------------------------------------------------------------------------\n   * Class Definition\n   * ------------------------------------------------------------------------\n   */\n  class BaseInput extends Base {\n    /**\n     *\n     * @param element\n     * @param config\n     * @param properties - anything that needs to be set as this[key] = value.  Works around the need to call `super` before using `this`\n     */\n    constructor($element, config, properties = {}) {\n      super($element, $.extend(true, {}, Default, config), properties);\n\n      // Enforce no overlap between components to prevent side effects\n      this._rejectInvalidComponentMatches();\n\n      // Enforce expected structure (if any)\n      this.rejectWithoutRequiredStructure();\n\n      // Enforce required classes for a consistent rendering\n      this._rejectWithoutRequiredClasses();\n\n      // Resolve the form-group first, it will be used for bmd-form-group if possible\n      //   note: different components have different rules\n      this.$formGroup = this.findFormGroup(this.config.formGroup.required);\n\n      // Will add bmd-form-group to form-group or create an bmd-form-group\n      //  Performance Note: for those forms that are really performance driven, create the markup with the .bmd-form-group to avoid\n      //    rendering changes once added.\n      this.$bmdFormGroup = this.resolveMdbFormGroup();\n\n      // Resolve and mark the bmdLabel if necessary as defined by the config\n      this.$bmdLabel = this.resolveMdbLabel();\n\n      // Signal to the bmd-form-group that a form-control-* variation is being used\n      this.resolveMdbFormGroupSizing();\n\n      this.addFocusListener();\n      this.addChangeListener();\n\n      if (this.$element.val() != \"\") {\n        this.addIsFilled();\n      }\n    }\n\n    dispose(dataKey) {\n      super.dispose(dataKey);\n      this.$bmdFormGroup = null;\n      this.$formGroup = null;\n    }\n\n    // ------------------------------------------------------------------------\n    // protected\n\n    rejectWithoutRequiredStructure() {\n      // implement\n    }\n\n    addFocusListener() {\n      this.$element\n        .on(\"focus\", () => {\n          this.addFormGroupFocus();\n        })\n        .on(\"blur\", () => {\n          this.removeFormGroupFocus();\n        });\n    }\n\n    addChangeListener() {\n      this.$element\n        .on(\"keydown paste\", event => {\n          if (Util.isChar(event)) {\n            this.addIsFilled();\n          }\n        })\n        .on(\"keyup change\", () => {\n          // make sure empty is added back when there is a programmatic value change.\n          //  NOTE: programmatic changing of value using $.val() must trigger the change event i.e. $.val('x').trigger('change')\n          if (this.isEmpty()) {\n            this.removeIsFilled();\n          } else {\n            this.addIsFilled();\n          }\n\n          if (this.config.validate) {\n            // Validation events do not bubble, so they must be attached directly to the text: http://jsfiddle.net/PEpRM/1/\n            //  Further, even the bind method is being caught, but since we are already calling #checkValidity here, just alter\n            //  the form-group on change.\n            //\n            // NOTE: I'm not sure we should be intervening regarding validation, this seems better as a README and snippet of code.\n            //        BUT, I've left it here for backwards compatibility.\n            let isValid =\n              typeof this.$element[0].checkValidity === \"undefined\" ||\n              this.$element[0].checkValidity();\n            if (isValid) {\n              this.removeHasDanger();\n            } else {\n              this.addHasDanger();\n            }\n          }\n        });\n    }\n\n    addHasDanger() {\n      this.$bmdFormGroup.addClass(ClassName.HAS_DANGER);\n    }\n\n    removeHasDanger() {\n      this.$bmdFormGroup.removeClass(ClassName.HAS_DANGER);\n    }\n\n    isEmpty() {\n      return (\n        this.$element.val() === null ||\n        this.$element.val() === undefined ||\n        this.$element.val() === \"\"\n      );\n    }\n\n    // Will add bmd-form-group to form-group or create a bmd-form-group if necessary\n    resolveMdbFormGroup() {\n      let mfg = this.findMdbFormGroup(false);\n      if (mfg === undefined || mfg.length === 0) {\n        if (\n          this.config.bmdFormGroup.create &&\n          (this.$formGroup === undefined || this.$formGroup.length === 0)\n        ) {\n          // If a form-group doesn't exist (not recommended), take a guess and wrap the element (assuming no label).\n          //  note: it's possible to make this smarter, but I need to see valid cases before adding any complexity.\n\n          // this may be an input-group, wrap that instead\n          if (this.outerElement().parent().hasClass(ClassName.INPUT_GROUP)) {\n            this.outerElement()\n              .parent()\n              .wrap(this.config.bmdFormGroup.template);\n          } else {\n            this.outerElement().wrap(this.config.bmdFormGroup.template);\n          }\n        } else {\n          // a form-group does exist, add our marker class to it\n          this.$formGroup.addClass(ClassName.BMD_FORM_GROUP);\n\n          // OLD: may want to implement this after all, see how the styling turns out, but using an existing form-group is less manipulation of the dom and therefore preferable\n          // A form-group does exist, so add an bmd-form-group wrapping it's internal contents\n          //fg.wrapInner(this.config.bmdFormGroup.template)\n        }\n\n        mfg = this.findMdbFormGroup(this.config.bmdFormGroup.required);\n      }\n\n      return mfg;\n    }\n\n    // Demarcation element (e.g. first child of a form-group)\n    //  Subclasses such as file inputs may have different structures\n    outerElement() {\n      return this.$element;\n    }\n\n    // Will add bmd-label to bmd-form-group if not already specified\n    resolveMdbLabel() {\n      let label = this.$bmdFormGroup.find(Selector.BMD_LABEL_WILDCARD);\n      if (label === undefined || label.length === 0) {\n        // we need to find it based on the configured selectors\n        label = this.findMdbLabel(this.config.label.required);\n\n        if (label === undefined || label.length === 0) {\n          // no label found, and finder did not require one\n        } else {\n          // a candidate label was found, add the configured default class name\n          label.addClass(this.config.label.className);\n        }\n      }\n\n      return label;\n    }\n\n    // Find bmd-label variant based on the config selectors\n    findMdbLabel(raiseError = true) {\n      let label = null;\n\n      // use the specified selector order\n      for (let selector of this.config.label.selectors) {\n        if ($.isFunction(selector)) {\n          label = selector(this);\n        } else {\n          label = this.$bmdFormGroup.find(selector);\n        }\n\n        if (label !== undefined && label.length > 0) {\n          break;\n        }\n      }\n\n      if (label.length === 0 && raiseError) {\n        $.error(\n          `Failed to find ${Selector.BMD_LABEL_WILDCARD} within form-group for ${Util.describe(\n            this.$element\n          )}`\n        );\n      }\n      return label;\n    }\n\n    // Find bmd-form-group\n    findFormGroup(raiseError = true) {\n      let fg = this.$element.closest(Selector.FORM_GROUP);\n      if (fg.length === 0 && raiseError) {\n        $.error(\n          `Failed to find ${Selector.FORM_GROUP} for ${Util.describe(\n            this.$element\n          )}`\n        );\n      }\n      return fg;\n    }\n\n    // Due to the interconnected nature of labels/inputs/help-blocks, signal the bmd-form-group-* size variation based on\n    //  a found form-control-* size\n    resolveMdbFormGroupSizing() {\n      if (!this.config.convertInputSizeVariations) {\n        return;\n      }\n\n      // Modification - Change text-sm/lg to form-group-sm/lg instead (preferred standard and simpler css/less variants)\n      for (let inputSize in FormControlSizeMarkers) {\n        if (this.$element.hasClass(inputSize)) {\n          //this.$element.removeClass(inputSize)\n          this.$bmdFormGroup.addClass(FormControlSizeMarkers[inputSize]);\n        }\n      }\n    }\n\n    // ------------------------------------------------------------------------\n    // private\n    _rejectInvalidComponentMatches() {\n      for (let otherComponent of this.config.invalidComponentMatches) {\n        otherComponent.rejectMatch(this.constructor.name, this.$element);\n      }\n    }\n\n    _rejectWithoutRequiredClasses() {\n      for (let requiredClass of this.config.requiredClasses) {\n        let found = false;\n        // allow one of several classes to be passed in x||y\n        if (requiredClass.indexOf(\"||\") !== -1) {\n          let oneOf = requiredClass.split(\"||\");\n          for (let requiredClass of oneOf) {\n            if (this.$element.hasClass(requiredClass)) {\n              found = true;\n              break;\n            }\n          }\n        } else if (this.$element.hasClass(requiredClass)) {\n          found = true;\n        }\n      }\n    }\n\n    // ------------------------------------------------------------------------\n    // static\n  }\n\n  return BaseInput;\n})(jQuery);\n\nexport default BaseInput;\n"]},"metadata":{},"sourceType":"module"}